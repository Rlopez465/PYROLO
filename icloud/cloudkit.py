import dataclasses
import logging
import random
import typing
import uuid
from typing import Literal
from io import BytesIO


import requests

from . import _utils, cloudkit_pb2, gsa

logger = logging.getLogger("cloudkit")


@dataclasses.dataclass
class Record:
    name: str  # UUID if autogenerated
    type: str
    fields: dict[str, typing.Any]
    zone: str = "_defaultZone"
    owner: str = "_defaultOwner"


class CloudKit:
    def __init__(
        self, dsid: str, cloudkit_token: str, mme_token: str, sandbox: bool = False
    ):
        """
        Represents a CloudKit user.
        `dsid`: The user's DSID.
        `cloudkit_token`: `cloudKitToken` from the `com.apple.mobileme` delegate.
        `mme_token`: `mmeAuthToken` from the `com.apple.mobileme` delegate.
        `sandbox`: Whether to use the CloudKit sandbox environment.
        """
        self.dsid = dsid
        self.cloudkit_token = cloudkit_token
        self.mme_token = mme_token
        self.sandbox = sandbox

    def container(
        self,
        container: str,
        scope: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
    ) -> "CloudKitContainer":
        """
        Convenience method for creating a CloudKitContainer object.
        """
        return CloudKitContainer(container, self, scope)

import hashlib
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

@dataclasses.dataclass
class CloudKitAsset:
    name: str
    extension: str
    data: bytes

    @dataclasses.dataclass
    class Chunk:
        data: bytes

        @classmethod
        def decrypt(cls, data, key): 
            iv = 16 * b'\x00'
            decryptor = Cipher(algorithms.AES(key), modes.CFB(iv)).decryptor()
            d = decryptor.update(data) + decryptor.finalize()
            return cls(d)
        
        def encrypt(self, key) -> bytes: 
            iv = 16 * b'\x00'
            encryptor = Cipher(algorithms.AES(key), modes.CFB(iv)).encryptor()
            d = encryptor.update(self.data) + encryptor.finalize()
            return d

        def checksum(self):
            return b'\x81' + hashlib.sha256(hashlib.sha256(self.data).digest()).digest()[:20]
    
    def chunks(self) -> list[Chunk]:
        return [self.Chunk(self.data)] # TODO: Implement chunking

    def hash(self) -> bytes:
        header = b"com.apple.XattrObjectSalt\0com.apple.DataObjectSalt\0"
        return b"\x01" + hashlib.sha1(header + self.data).digest()

    def _authorize_put(self, container: "CloudKitContainer", record, asset):
        headers = {
            "x-cloudkit-authtoken": container.user.cloudkit_token,
            "x-cloudkit-userid": container.user_id,
            "x-cloudkit-containerid": container.container,
            "x-cloudkit-bundleid": ".".join(
                container.container.split(".")[1:]
            ),  # Remove the "iCloud." prefix
            "x-cloudkit-databasescope": container.scope,
            "x-cloudkit-environment": "Sandbox" if container.user.sandbox else "Production",
            "accept": "application/x-protobuf",
            "content-type": 'application/x-protobuf; desc="https://gateway.icloud.com:443/static/protobuf/CloudDB/CloudDBClient.desc"; messageType=RequestOperation; delimited=true',
            "x-apple-operation-id": random.randbytes(8).hex(),
            "x-apple-request-uuid": str(uuid.uuid4()).upper(),
            "user-agent": "CloudKit/2060.11 (22F82)",
        }
        headers.update(gsa.generate_anisette_headers())

        body= _build_authorize_put(record, asset, container.container, container.user.sandbox, container.scope)
        r= requests.post("https://gateway.icloud.com/ckdatabase/api/client/asset/retrieve/token",
                      headers=headers,
                      data=body,
                      verify=False)
        
        print(r.content)


class CloudKitContainer:
    def __init__(
        self,
        container: str,
        user: CloudKit,
        scope: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
    ):
        """
        Represents a CloudKit container.
        container: The CloudKit container ID. (e.g. "iCloud.dev.jjtech.experiments.cktest")
        user: The CloudKit user to use for authentication.
        scope: The CloudKit database scope to use.
        """
        self.container = container
        self.user = user
        self.scope = scope
        self.user_id = self._fetch_user_id()

    def _fetch_user_id(self):
        headers = {
            "x-cloudkit-containerid": self.container,
            "x-cloudkit-bundleid": ".".join(
                self.container.split(".")[1:]
            ),  # Remove the "iCloud." prefix
            "x-cloudkit-databasescope": self.scope,
            "x-cloudkit-environment": "Sandbox" if self.user.sandbox else "Production",
            "accept": "application/x-protobuf",
            "x-apple-operation-id": random.randbytes(8).hex(),
            "x-apple-request-uuid": str(uuid.uuid4()).upper(),
        }

        headers.update(gsa.generate_anisette_headers())

        r = requests.post(
            "https://gateway.icloud.com/setup/setup/ck/v1/ckAppInit",
            params={"container": self.container},
            headers=headers,
            auth=(self.user.dsid, self.user.mme_token),
            verify=False,
        )

        logger.debug("Got app init response: ", r.content)
        return r.json()["cloudKitUserId"]

    def save_record(
        self, record: Record, zone: str = "_defaultZone", owner: str = "_defaultOwner"
    ) -> None:
        """
        Saves a record to the container.
        """
        logger.info(f"Saving record {record.name} to {self.container}")

        headers = {
            "x-cloudkit-authtoken": self.user.cloudkit_token,
            "x-cloudkit-userid": self.user_id,
            "x-cloudkit-containerid": self.container,
            "x-cloudkit-bundleid": ".".join(
                self.container.split(".")[1:]
            ),  # Remove the "iCloud." prefix
            "x-cloudkit-databasescope": self.scope,
            "x-cloudkit-environment": "Sandbox" if self.user.sandbox else "Production",
            "accept": "application/x-protobuf",
            "content-type": 'application/x-protobuf; desc="https://gateway.icloud.com:443/static/protobuf/CloudDB/CloudDBClient.desc"; messageType=RequestOperation; delimited=true',
            "x-apple-operation-id": random.randbytes(8).hex(),
            "x-apple-request-uuid": str(uuid.uuid4()).upper(),
            "user-agent": "CloudKit/2060.11 (22F82)",
        }

        headers.update(gsa.generate_anisette_headers())

        body = _build_record_save_request(
            record, self.container, self.user.sandbox, self.scope, zone, owner
        )
        r = requests.post(
            "https://gateway.icloud.com/ckdatabase/api/client/record/save",
            headers=headers,
            data=body,
            verify=False,
        )

        _parse_response(
            r.content
        )  # Will raise an exception if the response is an error


def _parse_response(response: bytes):
    try:
        r = cloudkit_pb2.ResponseOperation.FromString(_undelimit_messages(response)[0])
    except Exception as e:
        logger.warning(f"Failed to parse response: {e} {response.hex()}")
        raise

    if r.result.code != cloudkit_pb2.ResponseOperation.Result.Code.SUCCESS:
        if r.result.code == cloudkit_pb2.ResponseOperation.Result.Code.FAILURE:
            raise Exception(
                f"CloudKit request failed: {r.result.error.errorDescription}"
            )
        else:
            raise Exception("Unknown CloudKit error")


def _build_header(
    container: str,
    sandbox: bool = False,
    database: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
):
    hardware_id = uuid.uuid4()  # Generate a new hardware ID for each request?

    header = cloudkit_pb2.RequestOperation.Header()
    header.applicationContainer = container
    header.applicationContainerEnvironment = (
        cloudkit_pb2.RequestOperation.Header.ContainerEnvironment.SANDBOX
        if sandbox
        else cloudkit_pb2.RequestOperation.Header.ContainerEnvironment.PRODUCTION
    )

    header.deviceHardwareID = str(hardware_id).upper()

    if database == "PUBLIC":
        header.targetDatabase = cloudkit_pb2.RequestOperation.Header.Database.PUBLIC_DB
    elif database == "PRIVATE":
        header.targetDatabase = cloudkit_pb2.RequestOperation.Header.Database.PRIVATE_DB
    elif database == "SHARED":
        header.targetDatabase = cloudkit_pb2.RequestOperation.Header.Database.SHARED_DB

    header.isolationLevel = cloudkit_pb2.RequestOperation.Header.IsolationLevel.ZONE

    return header

def _build_authorize_put(
    record: Record,
    asset: CloudKitAsset,
    container: str,
    sandbox: bool = False,
    database: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
):
    request = cloudkit_pb2.RequestOperation()
    request.header.CopyFrom(_build_header(container, sandbox, database))

    request.request.operationUUID = str(uuid.uuid4()).upper()
    request.request.type = cloudkit_pb2.Operation.Type.ASSET_UPLOAD_TOKEN_RETRIEVE_TYPE
    request.request.last = True

    request.assetUploadTokenRetrieveRequest.assetUpload.record.CopyFrom(_build_record_identifier(record))
    request.assetUploadTokenRetrieveRequest.assetUpload.recordType.name = record.type

    request.assetUploadTokenRetrieveRequest.assetUpload.asset.name.name = asset.name

    request.assetUploadTokenRetrieveRequest.assetUpload.asset.data.sig = asset.hash()
    request.assetUploadTokenRetrieveRequest.assetUpload.asset.data.size = len(asset.data)
    request.assetUploadTokenRetrieveRequest.assetUpload.asset.data.associatedRecord.CopyFrom(_build_record_identifier(record))


    for chunk in asset.chunks():
        #c = cloudkit_pb2.AssetUploadTokenRetrieveRequest.AssetUpload.Asset.Chunk()
        #c.size = len(chunk.data)
        #c.associatedRecord.CopyFrom(_build_record_identifier(record))
        #equest.assetUploadTokenRetrieveRequest.assetUpload.asset.chunks.append(c)

        key = random.randbytes(16)
        request.assetUploadTokenRetrieveRequest.authorizePut.data.chunks.append(cloudkit_pb2.AssetUploadTokenRetrieveRequest.AuthorizePut.PutData.ChunkInfo(chunk_checksum=chunk.checksum(), chunk_encryption_key = b"\x01" + key, chunk_length=len(chunk.data)))
        
    request.assetUploadTokenRetrieveRequest.header.append(cloudkit_pb2.AssetUploadTokenRetrieveRequest.NamedHeader(name="x-apple-mmcs-proto-version", value="5.0"))
    request.assetUploadTokenRetrieveRequest.header.append(cloudkit_pb2.AssetUploadTokenRetrieveRequest.NamedHeader(name="x-apple-mmcs-plist-sha256", value="fvj0Y/Ybu1pq0r4NxXw3eP51exujUkEAd7LllbkTdK8="))
    request.assetUploadTokenRetrieveRequest.header.append(cloudkit_pb2.AssetUploadTokenRetrieveRequest.NamedHeader(name="x-apple-mmcs-plist-version", value="v1.0"))
    request.assetUploadTokenRetrieveRequest.header.append(cloudkit_pb2.AssetUploadTokenRetrieveRequest.NamedHeader(name="x-mme-client-info", value="<MacBookPro18,3> <macOS;13.4.1;22F82> <com.apple.icloud.content/2050.13.1.1 (com.apple.CloudKit/(null))>"))

    request.assetUploadTokenRetrieveRequest.unk1 = 1
    request.assetUploadTokenRetrieveRequest.authorizePut.f3 = 81
    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.f103 = 1
    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.unk_date = "2022-08-11"



    request.assetUploadTokenRetrieveRequest.authorizePut.data.sig = asset.hash()
    request.assetUploadTokenRetrieveRequest.authorizePut.data.token = ""

    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.chunk_count = len(asset.chunks())
    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.profile_type = "kCKProfileTypeRabin"
    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.extension = asset.extension

    return _delimit_messages([request.SerializeToString()])



def _build_record_identifier(record: Record):
    record_identifier = cloudkit_pb2.RecordIdentifier()
    record_identifier.value.name = record.name
    record_identifier.value.type = cloudkit_pb2.Identifier.Type.RECORD

    record_identifier.zoneIdentifier.value.name = record.zone
    record_identifier.zoneIdentifier.value.type = (
        cloudkit_pb2.Identifier.Type.RECORD_ZONE
    )

    record_identifier.zoneIdentifier.ownerIdentifier.name = record.owner
    record_identifier.zoneIdentifier.ownerIdentifier.type = (
        cloudkit_pb2.Identifier.Type.USER
    )

    return record_identifier

def _delimit_messages(messages: list[bytes]):
    output = BytesIO()
    for message in messages:
        output.write(_utils.ULEB128.encode(len(message)))
        output.write(message)
    return output.getvalue()


def _undelimit_messages(data: bytes):
    output = []
    datar = BytesIO(data)
    while True:
        # Make sure we don't read past the end of the data
        if datar.tell() >= len(data):
            break
        length, read = _utils.ULEB128.decode_reader(datar)
        if length == 0:
            break
        output.append(datar.read(length))
    return output


def _build_record_save_request(
    record: Record,
    container: str,
    sandbox: bool = False,
    database: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
    zone: str = "_defaultZone",
    owner: str = "_defaultOwner",
):
    operation_uuid = uuid.uuid4()  # Generate a new operation UUID for each request?
    # record_id = uuid.uuid4()  # Generate a new record ID for each request?

    request = cloudkit_pb2.RequestOperation()
    request.header.CopyFrom(_build_header(container, sandbox, database))

    request.request.operationUUID = str(operation_uuid).upper()
    request.request.type = cloudkit_pb2.Operation.Type.RECORD_SAVE_TYPE
    request.request.last = True

    request.recordSaveRequest.record.recordIdentifier.value.name = record.name
    request.recordSaveRequest.record.recordIdentifier.value.type = (
        cloudkit_pb2.Identifier.Type.RECORD
    )

    request.recordSaveRequest.record.recordIdentifier.zoneIdentifier.value.name = zone
    request.recordSaveRequest.record.recordIdentifier.zoneIdentifier.value.type = (
        cloudkit_pb2.Identifier.Type.RECORD_ZONE
    )

    request.recordSaveRequest.record.recordIdentifier.zoneIdentifier.ownerIdentifier.name = (
        owner
    )
    request.recordSaveRequest.record.recordIdentifier.zoneIdentifier.ownerIdentifier.type = (
        cloudkit_pb2.Identifier.Type.USER
    )

    request.recordSaveRequest.record.type.name = record.type

    for key, value in record.fields.items():
        request.recordSaveRequest.record.recordField.append(cloudkit_pb2.Record.Field())
        request.recordSaveRequest.record.recordField[-1].identifier.name = key
        request.recordSaveRequest.record.recordField[
            -1
        ].value.type = cloudkit_pb2.Record.Field.Value.Type.STRING_TYPE
        request.recordSaveRequest.record.recordField[-1].value.stringValue = value

    return _delimit_messages([request.SerializeToString()])
