import dataclasses
import logging
import random
import typing
import uuid
from typing import Literal
from io import BytesIO


import requests

from . import _utils, cloudkit_pb2, gsa, mmcs

logger = logging.getLogger("cloudkit")


@dataclasses.dataclass
class Record:
    name: str  # UUID if autogenerated
    type: str
    fields: dict[str, typing.Any]
    zone: str = "_defaultZone"
    owner: str = "_defaultOwner"

@dataclasses.dataclass
class Asset:
    name: str
    extension: str
    data: bytes

    def hash(self) -> bytes:
        header = b"com.apple.XattrObjectSalt\0com.apple.DataObjectSalt\0"
        return b"\x01" + hashlib.sha1(header + self.data).digest()
    
class User:
    def __init__(
        self, dsid: str, cloudkit_token: str, mme_token: str, sandbox: bool = False
    ):
        """
        Represents a CloudKit user.
        `dsid`: The user's DSID.
        `cloudkit_token`: `cloudKitToken` from the `com.apple.mobileme` delegate.
        `mme_token`: `mmeAuthToken` from the `com.apple.mobileme` delegate.
        `sandbox`: Whether to use the CloudKit sandbox environment.
        """
        self.dsid = dsid
        self.cloudkit_token = cloudkit_token
        self.mme_token = mme_token
        self.sandbox = sandbox

    def container(
        self,
        container: str,
        scope: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
    ) -> "Container":
        """
        Convenience method for creating a CloudKitContainer object.
        """
        return Container(container, self, scope)

import hashlib
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes


class Container:
    def __init__(
        self,
        container: str,
        user: User,
        scope: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
    ):
        """
        Represents a CloudKit container.
        container: The CloudKit container ID. (e.g. "iCloud.dev.jjtech.experiments.cktest")
        user: The CloudKit user to use for authentication.
        scope: The CloudKit database scope to use.
        """
        self.container = container
        self.user = user
        self.scope = scope
        self.user_id = self._fetch_user_id()


    def _headers(self, auth: bool = True):
        h = {
            "x-cloudkit-containerid": self.container,
            "x-cloudkit-bundleid": ".".join(
                self.container.split(".")[1:]
            ),  # Remove the "iCloud." prefix
            "x-cloudkit-databasescope": self.scope,
            "x-cloudkit-environment": "Sandbox" if self.user.sandbox else "Production",
            "accept": "application/x-protobuf",
            "x-apple-operation-id": random.randbytes(8).hex(),
            "x-apple-request-uuid": str(uuid.uuid4()).upper(),
            "user-agent": "CloudKit/2060.11 (22F82)",
        }
        if auth:
            h["x-cloudkit-authtoken"] = self.user.cloudkit_token
            h["x-cloudkit-userid"] = self.user_id
            h["content-type"] = 'application/x-protobuf; desc="https://gateway.icloud.com:443/static/protobuf/CloudDB/CloudDBClient.desc"; messageType=RequestOperation; delimited=true'
        return h
    
    def _fetch_user_id(self):
        headers = self._headers(auth=False)

        headers.update(gsa.generate_anisette_headers())

        r = requests.post(
            "https://gateway.icloud.com/setup/setup/ck/v1/ckAppInit",
            params={"container": self.container},
            headers=headers,
            auth=(self.user.dsid, self.user.mme_token),
            verify=False,
        )

        logger.debug("Got app init response: ", r.content)
        return r.json()["cloudKitUserId"]

    def save_record(
        self, record: Record, zone: str = "_defaultZone", owner: str = "_defaultOwner"
    ) -> None:
        """
        Saves a record to the container.
        """
        logger.info(f"Saving record {record.name} to {self.container}")

        headers = self._headers()

        headers.update(gsa.generate_anisette_headers())

        body = _build_record_save_request(
            record, self.container, self.user.sandbox, self.scope, zone, owner
        )
        r = requests.post(
            "https://gateway.icloud.com/ckdatabase/api/client/record/save",
            headers=headers,
            data=body,
            verify=False,
        )

        _parse_response(
            r.content
        )  # Will raise an exception if the response is an error

    def _upload_asset(self, record: Record, asset: Asset): # Called by save_record when the record has an asset attached
        headers = self._headers()

        headers.update(gsa.generate_anisette_headers())

        # Chunk the asset
        chunks = mmcs.chunk(asset.data) # list[tuple[hash, key, data]]

        body = _build_authorize_put(self, record, asset, chunks)
        r = requests.post(
            "https://gateway.icloud.com/ckdatabase/api/client/asset/retrieve/token",
            headers=headers,
            data=body,
            verify=False,
        )

        r = _parse_response(r.content)

        print(r.assetUploadTokenRetrieveResponse)

        buckets = [] # dict[Bucket, list[tuple[hash, key, data]]]
        for bucket in r.assetUploadTokenRetrieveResponse.uploadInfo.buckets:
            b = mmcs.Bucket(
                bucket.url.protocol2 + "://" + bucket.url.domain + ":" + str(bucket.url.port) + bucket.url.path, 
                {header.name: header.value for header in bucket.url.headers},
                [chunk.hash for chunk in bucket.chunks]
                )
            buckets.append(b)
            
            # for chunk_h in bucket.chunks:
            #     chunk_hash = chunk_h.hash
            #     print(chunk_hash.hex())
            #     # Check for the chunk in chunks list
            #     for chunk in chunks:
            #         print(chunk[0].hex())
            #         if chunk[0] == chunk_hash:

            #             upload.append({b: chunk})
            #             break
            #upload.append({bucket: []}
        #print(upload)

        mmcs.upload_chunks(chunks, buckets)
            

        # map: mmcs.ChunkMap = {} # TODO: STUB

        # file.upload(map)

        # # CompletePut





def _parse_response(response: bytes):
    try:
        #import base64
        #print(base64.b64encode(_undelimit_messages(response)[0]))
        r = cloudkit_pb2.ResponseOperation.FromString(_undelimit_messages(response)[0])
    except Exception as e:
        logger.warning(f"Failed to parse response: {e} {response.hex()}")
        raise

    if r.result.code != cloudkit_pb2.ResponseOperation.Result.Code.SUCCESS:
        if r.result.code == cloudkit_pb2.ResponseOperation.Result.Code.FAILURE:
            raise Exception(
                f"CloudKit request failed: {r.result.error.errorDescription}"
            )
        else:
            raise Exception("Unknown CloudKit error")
        
    return r

def _build_header(
    container: str,
    sandbox: bool = False,
    database: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
):
    hardware_id = uuid.uuid4()  # Generate a new hardware ID for each request?

    header = cloudkit_pb2.RequestOperation.Header()
    header.applicationContainer = container
    header.applicationContainerEnvironment = (
        cloudkit_pb2.RequestOperation.Header.ContainerEnvironment.SANDBOX
        if sandbox
        else cloudkit_pb2.RequestOperation.Header.ContainerEnvironment.PRODUCTION
    )

    header.deviceHardwareID = str(hardware_id).upper()

    if database == "PUBLIC":
        header.targetDatabase = cloudkit_pb2.RequestOperation.Header.Database.PUBLIC_DB
    elif database == "PRIVATE":
        header.targetDatabase = cloudkit_pb2.RequestOperation.Header.Database.PRIVATE_DB
    elif database == "SHARED":
        header.targetDatabase = cloudkit_pb2.RequestOperation.Header.Database.SHARED_DB

    header.isolationLevel = cloudkit_pb2.RequestOperation.Header.IsolationLevel.ZONE

    return header

def _build_authorize_put(
    container: Container,
    record: Record, # record to attach to
    asset: Asset, # asset metadata, unencrypted
    chunks: list[tuple[bytes, bytes, bytes]],
) -> bytes:
    request = cloudkit_pb2.RequestOperation()
    request.header.CopyFrom(_build_header(container.container, container.user.sandbox, container.scope))

    request.request.operationUUID = str(uuid.uuid4()).upper()
    request.request.type = cloudkit_pb2.Operation.Type.ASSET_UPLOAD_TOKEN_RETRIEVE_TYPE
    request.request.last = True

    request.assetUploadTokenRetrieveRequest.assetUpload.record.CopyFrom(_build_record_identifier(record))
    request.assetUploadTokenRetrieveRequest.assetUpload.recordType.name = record.type

    request.assetUploadTokenRetrieveRequest.assetUpload.asset.name.name = asset.name

    request.assetUploadTokenRetrieveRequest.assetUpload.asset.data.sig = asset.hash()
    request.assetUploadTokenRetrieveRequest.assetUpload.asset.data.size = len(asset.data)
    request.assetUploadTokenRetrieveRequest.assetUpload.asset.data.associatedRecord.CopyFrom(_build_record_identifier(record))


    for chunk in chunks:
        #tuple[hash, key, data]
        request.assetUploadTokenRetrieveRequest.authorizePut.data.chunks.append(cloudkit_pb2.AssetUploadTokenRetrieveRequest.AuthorizePut.PutData.ChunkInfo(chunk_checksum=chunk[0], chunk_encryption_key = b"\x01" + chunk[1], chunk_length=len(chunk[2])))
        
    request.assetUploadTokenRetrieveRequest.header.append(cloudkit_pb2.NamedHeader(name="x-apple-mmcs-proto-version", value="5.0"))
    request.assetUploadTokenRetrieveRequest.header.append(cloudkit_pb2.NamedHeader(name="x-apple-mmcs-plist-sha256", value="fvj0Y/Ybu1pq0r4NxXw3eP51exujUkEAd7LllbkTdK8="))
    request.assetUploadTokenRetrieveRequest.header.append(cloudkit_pb2.NamedHeader(name="x-apple-mmcs-plist-version", value="v1.0"))
    request.assetUploadTokenRetrieveRequest.header.append(cloudkit_pb2.NamedHeader(name="x-mme-client-info", value="<MacBookPro18,3> <macOS;13.4.1;22F82> <com.apple.icloud.content/2050.13.1.1 (com.apple.CloudKit/(null))>"))

    request.assetUploadTokenRetrieveRequest.unk1 = 1
    request.assetUploadTokenRetrieveRequest.authorizePut.f3 = 81
    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.f103 = 1
    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.unk_date = "2022-08-11"



    request.assetUploadTokenRetrieveRequest.authorizePut.data.sig = asset.hash()
    request.assetUploadTokenRetrieveRequest.authorizePut.data.token = ""

    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.chunk_count = len(chunks)
    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.profile_type = "kCKProfileTypeRabin"
    request.assetUploadTokenRetrieveRequest.authorizePut.data.footer.extension = asset.extension

    #print(request)

    return _delimit_messages([request.SerializeToString()])



def _build_record_identifier(record: Record):
    record_identifier = cloudkit_pb2.RecordIdentifier()
    record_identifier.value.name = record.name
    record_identifier.value.type = cloudkit_pb2.Identifier.Type.RECORD

    record_identifier.zoneIdentifier.value.name = record.zone
    record_identifier.zoneIdentifier.value.type = (
        cloudkit_pb2.Identifier.Type.RECORD_ZONE
    )

    record_identifier.zoneIdentifier.ownerIdentifier.name = record.owner
    record_identifier.zoneIdentifier.ownerIdentifier.type = (
        cloudkit_pb2.Identifier.Type.USER
    )

    return record_identifier

def _delimit_messages(messages: list[bytes]):
    output = BytesIO()
    for message in messages:
        output.write(_utils.ULEB128.encode(len(message)))
        output.write(message)
    return output.getvalue()


def _undelimit_messages(data: bytes):
    output = []
    datar = BytesIO(data)
    while True:
        # Make sure we don't read past the end of the data
        if datar.tell() >= len(data):
            break
        length, read = _utils.ULEB128.decode_reader(datar)
        if length == 0:
            break
        output.append(datar.read(length))
    return output


def _build_record_save_request(
    record: Record,
    container: str,
    sandbox: bool = False,
    database: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
    zone: str = "_defaultZone",
    owner: str = "_defaultOwner",
):
    operation_uuid = uuid.uuid4()  # Generate a new operation UUID for each request?
    # record_id = uuid.uuid4()  # Generate a new record ID for each request?

    request = cloudkit_pb2.RequestOperation()
    request.header.CopyFrom(_build_header(container, sandbox, database))

    request.request.operationUUID = str(operation_uuid).upper()
    request.request.type = cloudkit_pb2.Operation.Type.RECORD_SAVE_TYPE
    request.request.last = True

    request.recordSaveRequest.record.recordIdentifier.value.name = record.name
    request.recordSaveRequest.record.recordIdentifier.value.type = (
        cloudkit_pb2.Identifier.Type.RECORD
    )

    request.recordSaveRequest.record.recordIdentifier.zoneIdentifier.value.name = zone
    request.recordSaveRequest.record.recordIdentifier.zoneIdentifier.value.type = (
        cloudkit_pb2.Identifier.Type.RECORD_ZONE
    )

    request.recordSaveRequest.record.recordIdentifier.zoneIdentifier.ownerIdentifier.name = (
        owner
    )
    request.recordSaveRequest.record.recordIdentifier.zoneIdentifier.ownerIdentifier.type = (
        cloudkit_pb2.Identifier.Type.USER
    )

    request.recordSaveRequest.record.type.name = record.type

    for key, value in record.fields.items():
        request.recordSaveRequest.record.recordField.append(cloudkit_pb2.Record.Field())
        request.recordSaveRequest.record.recordField[-1].identifier.name = key
        request.recordSaveRequest.record.recordField[
            -1
        ].value.type = cloudkit_pb2.Record.Field.Value.Type.STRING_TYPE
        request.recordSaveRequest.record.recordField[-1].value.stringValue = value

    return _delimit_messages([request.SerializeToString()])
