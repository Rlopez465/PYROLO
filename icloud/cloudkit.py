import dataclasses
import logging
import random
import typing
import uuid
from typing import Literal
from io import BytesIO
import hashlib

import requests

from . import _utils, gsa, mmcs, _cloudkit

logger = logging.getLogger("cloudkit")


@dataclasses.dataclass
class Record:
    name: str  # UUID if autogenerated
    type: str
    fields: dict[str, typing.Any]
    zone: str = "_defaultZone"
    owner: str = "_defaultOwner"

    def identifier(self):
        return _cloudkit.RecordIdentifier(
            value=_cloudkit.Identifier(
                name=self.name,
                type=_cloudkit.IdentifierType.RECORD,
            ),
            zone_identifier=_cloudkit.RecordZoneIdentifier(
                value=_cloudkit.Identifier(
                    name=self.zone,
                    type=_cloudkit.IdentifierType.RECORD_ZONE,
                ),
                owner_identifier=_cloudkit.Identifier(
                    name=self.owner, type=_cloudkit.IdentifierType.USER
                ),
            ),
        )


@dataclasses.dataclass
class Asset:
    name: str
    extension: str
    data: bytes

    def hash(self) -> bytes:
        header = b"com.apple.XattrObjectSalt\0com.apple.DataObjectSalt\0"
        return b"\x01" + hashlib.sha1(header + self.data).digest()


class User:
    def __init__(
        self, dsid: str, cloudkit_token: str, mme_token: str, sandbox: bool = False
    ):
        """
        Represents a CloudKit user.
        `dsid`: The user's DSID.
        `cloudkit_token`: `cloudKitToken` from the `com.apple.mobileme` delegate.
        `mme_token`: `mmeAuthToken` from the `com.apple.mobileme` delegate.
        `sandbox`: Whether to use the CloudKit sandbox environment.
        """
        self.dsid = dsid
        self.cloudkit_token = cloudkit_token
        self.mme_token = mme_token
        self.sandbox = sandbox

    def container(
        self,
        container: str,
        scope: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
    ) -> "Container":
        """
        Convenience method for creating a CloudKitContainer object.
        """
        return Container(container, self, scope)


class Container:
    def __init__(
        self,
        container: str,
        user: User,
        scope: Literal["PUBLIC"] | Literal["PRIVATE"] | Literal["SHARED"] = "PUBLIC",
    ):
        """
        Represents a CloudKit container.
        container: The CloudKit container ID. (e.g. "iCloud.dev.jjtech.experiments.cktest")
        user: The CloudKit user to use for authentication.
        scope: The CloudKit database scope to use.
        """
        self.container = container
        self.user = user
        self.scope = scope
        self.user_id = self._fetch_user_id()

    def _headers(self, auth: bool = True):
        h = {
            "x-cloudkit-containerid": self.container,
            "x-cloudkit-bundleid": ".".join(
                self.container.split(".")[1:]
            ),  # Remove the "iCloud." prefix
            "x-cloudkit-databasescope": self.scope,
            "x-cloudkit-environment": "Sandbox" if self.user.sandbox else "Production",
            "accept": "application/x-protobuf",
            "x-apple-operation-id": random.randbytes(8).hex(),
            "x-apple-request-uuid": str(uuid.uuid4()).upper(),
            "user-agent": "CloudKit/2060.11 (22F82)",
        }
        if auth:
            h["x-cloudkit-authtoken"] = self.user.cloudkit_token
            h["x-cloudkit-userid"] = self.user_id
            h[
                "content-type"
            ] = 'application/x-protobuf; desc="https://gateway.icloud.com:443/static/protobuf/CloudDB/CloudDBClient.desc"; messageType=RequestOperation; delimited=true'
        return h

    def _mmcs_headers(self):
        h = self._headers(auth=False)
        h.update(
            {
                "x-cloudkit-container": self.container,
                "x-mme-client-info": gsa.build_client(
                    app_bundle="com.apple.CloudKit",
                    app_version="(null)",
                    authkit_bundle="com.apple.icloud.content",
                    authkit_version="2050.13.1.1",
                ),
                "x-apple-mmcs-dataclass": "com.apple.Dataclass.CloudKit",
                "x-apple-mme-dsid": self.user.dsid,
                "accept": "application/vnd.com.apple.me.ubchunk+protobuf",
                "content-type": "application/vnd.com.apple.me.ubchunk+protobuf",
                "x-cloudkit-zones": "_defaultZone",  # FIXME
            }
        )
        h.update(mmcs.MMCS_HEADERS)
        return h

    def _fetch_user_id(self):
        headers = self._headers(auth=False)

        headers.update(gsa.generate_anisette_headers())

        r = requests.post(
            "https://gateway.icloud.com/setup/setup/ck/v1/ckAppInit",
            params={"container": self.container},
            headers=headers,
            auth=(self.user.dsid, self.user.mme_token),
            verify=False,
        )

        logger.debug("Got app init response: ", r.content)
        return r.json()["cloudKitUserId"]

    def save_record(self, record: Record) -> None:
        """
        Saves a record to the container.
        """
        logger.info(f"Saving record {record.name} to {self.container}")

        headers = self._headers()

        headers.update(gsa.generate_anisette_headers())

        body = _delimit_messages(
            [
                bytes(
                    _cloudkit.RequestOperation(
                        header=_cloudkit.RequestOperationHeader(
                            application_container=self.container,
                            application_container_environment=_cloudkit.RequestOperationHeaderContainerEnvironment.SANDBOX
                            if self.user.sandbox
                            else _cloudkit.RequestOperationHeaderContainerEnvironment.PRODUCTION,
                            device_hardware_i_d=str(uuid.uuid4()).upper(),
                            target_database=_cloudkit.RequestOperationHeaderDatabase.PUBLIC_DB
                            if self.scope == "PUBLIC"
                            else _cloudkit.RequestOperationHeaderDatabase.PRIVATE_DB
                            if self.scope == "PRIVATE"
                            else _cloudkit.RequestOperationHeaderDatabase.SHARED_DB,
                            isolation_level=_cloudkit.RequestOperationHeaderIsolationLevel.ZONE,
                        ),
                        request=_cloudkit.Operation(
                            operation_u_u_i_d=str(uuid.uuid4()).upper(),
                            type=_cloudkit.OperationType.RECORD_SAVE_TYPE,
                            last=True,
                        ),
                        record_save_request=_cloudkit.RecordSaveRequest(
                            record=_cloudkit.Record(
                                record_identifier=record.identifier(),
                                type=_cloudkit.RecordType(name=record.type),
                                record_field=[
                                    _cloudkit.RecordField(
                                        identifier=_cloudkit.RecordFieldIdentifier(key),
                                        value=_cloudkit.RecordFieldValue(
                                            type=_cloudkit.RecordFieldValueType.STRING_TYPE,
                                            string_value=value,
                                        ),
                                    )
                                    for key, value in record.fields.items()
                                ],
                            )
                        ),
                    )
                )
            ]
        )

        r = requests.post(
            "https://gateway.icloud.com/ckdatabase/api/client/record/save",
            headers=headers,
            data=body,
            verify=False,
        )

        r = _cloudkit.ResponseOperation().parse(_undelimit_messages(r.content)[0])

        if r.result.code != _cloudkit.ResponseOperationResultCode.SUCCESS:
            logger.error(f"CloudKit request failed: {r.result.error.error_description}")
            raise Exception(
                f"CloudKit request failed: {r.result.error.error_description}"
            )

    def _upload_asset(
        self, record: Record, asset: Asset
    ):  # Called by save_record when the record has an asset attached
        headers = self._headers()

        headers.update(gsa.generate_anisette_headers())

        # Chunk the asset
        chunks = mmcs.chunk(asset.data)  # list[tuple[hash, key, data]]

        body = _build_authorize_put(self, record, asset, chunks)
        r = requests.post(
            "https://gateway.icloud.com/ckdatabase/api/client/asset/retrieve/token",
            headers=headers,
            data=body,
            verify=False,
        )

        r = _cloudkit.ResponseOperation().parse(_undelimit_messages(r.content)[0])

        print(r.asset_upload_token_retrieve_response)

        buckets: list[mmcs.Bucket] = []
        for bucket in r.asset_upload_token_retrieve_response.upload_info.buckets:
            b = mmcs.Bucket(
                bucket.bucket_name,
                bucket.unk1,
                bucket.url.protocol2
                + "://"
                + bucket.url.domain
                + ":"
                + str(bucket.url.port)
                + bucket.url.path,
                {header.name: header.value for header in bucket.url.headers},
                [mmcs.Chunk(hash=chunk.hash) for chunk in bucket.chunks],
            )
            buckets.append(b)

        receipts = mmcs.upload_chunks(chunks, buckets)

        headers = self._mmcs_headers()
        headers[
            "x-apple-mmcs-auth"
        ] = f"{buckets[0].name} {receipts[0].size} {buckets[0].token}"

        requests.post(
            f"https://gateway.icloud.com/content/CiCloud.dev.jjtech.experiments.cktest/putComplete",
            headers=headers,
            data=_build_put_complete(
                buckets,
                r.asset_upload_token_retrieve_response.upload_info.validate,
                receipts,
            ),
            verify=False,
        )

        # # CompletePut


def _build_put_complete(buckets: list[mmcs.Bucket], validate, receipts: list[mmcs.UploadReceipt]):
    p = _cloudkit.PutComplete()
    for i in range(len(buckets)):
        bucket = buckets[i]
        l = receipts[i]
        p.receipt.append(
            _cloudkit.PutCompleteReceipt(
                url=bucket.url,
                status=200,
                verify=bucket.token,
                unk2=0,
                headers=[
                    _cloudkit.NamedHeader(k, v)
                    for k, v in l.headers.items()
                    if k.lower() == "etag"
                    or k.lower() == "x-apple-edge-info"
                ],
            ),
            # header={
            #     header.name: header.value
            #     for header in l[1].headers
            #     if header.name.lower() == "etag"
            #     or header.name.lower() == "x-apple-edge-info"
            # },
        )
    # request = cloudkit_pb2.PutComplete()
    # request.receipt.append(cloudkit_pb2.PutComplete.Receipt(url=buckets[0].url, status=200, verify=buckets[0].token, unk2=0))
    # for header in lens[0][1].headers.keys():
    #     if header.lower() == "etag" or header.lower() == "x-apple-edge-info":
    #         request.receipt[0].headers.append(cloudkit_pb2.NamedHeader(name=header, value=lens[0][1].headers[header]))
    p.validate = validate
    return _delimit_messages([bytes(p)])


def _build_authorize_put(
    container: Container,
    record: Record,  # record to attach to
    asset: Asset,  # asset metadata, unencrypted
    chunks: list[mmcs.Chunk],
) -> bytes:
    request = _cloudkit.RequestOperation(
        header=_cloudkit.RequestOperationHeader(
            application_container=container.container,
            application_container_environment=_cloudkit.RequestOperationHeaderContainerEnvironment.SANDBOX
            if container.user.sandbox
            else _cloudkit.RequestOperationHeaderContainerEnvironment.PRODUCTION,
            device_hardware_i_d=str(uuid.uuid4()).upper(),
            target_database=_cloudkit.RequestOperationHeaderDatabase.PUBLIC_DB
            if container.scope == "PUBLIC"
            else _cloudkit.RequestOperationHeaderDatabase.PRIVATE_DB
            if container.scope == "PRIVATE"
            else _cloudkit.RequestOperationHeaderDatabase.SHARED_DB,
            isolation_level=_cloudkit.RequestOperationHeaderIsolationLevel.ZONE,
        ),
        request=_cloudkit.Operation(
            operation_u_u_i_d=str(uuid.uuid4()).upper(),
            type=_cloudkit.OperationType.ASSET_UPLOAD_TOKEN_RETRIEVE_TYPE,
            last=True,
        ),
        asset_upload_token_retrieve_request=_cloudkit.AssetUploadTokenRetrieveRequest(
            asset_upload=_cloudkit.AssetUploadTokenRetrieveRequestAssetUpload(
                record=record.identifier(),
                record_type=_cloudkit.RecordType(record.type),
                asset=_cloudkit.AssetUploadTokenRetrieveRequestAssetUploadAsset(
                    name=_cloudkit.AssetUploadTokenRetrieveRequestAssetUploadName(asset.name),
                    #name=asset.name,
                    data=_cloudkit.AssetUploadTokenRetrieveRequestAssetUploadAssetAssetData(
                        sig=asset.hash(),
                        size=len(asset.data),
                        associated_record=record.identifier(),
                    ),
                ),
            ),
            authorize_put=_cloudkit.AssetUploadTokenRetrieveRequestAuthorizePut(
                data=_cloudkit.AssetUploadTokenRetrieveRequestAuthorizePutPutData(
                    sig=asset.hash(),
                    token=" ",
                    footer=_cloudkit.AssetUploadTokenRetrieveRequestAuthorizePutPutDataFooter(
                        chunk_count=len(chunks),
                        profile_type="kCKProfileTypeRabin",
                        extension=asset.extension,
                        unk_date="2022-08-11",
                        f103=1,
                    ),
                     #       request.assetUploadTokenRetrieveRequest.authorizePut.data.chunks.append(cloudkit_pb2.AssetUploadTokenRetrieveRequest.AuthorizePut.PutData.ChunkInfo(chunk_checksum=chunk[0], chunk_encryption_key = b"\x01" + chunk[1], chunk_length=len(chunk[2])))
                    
                    chunks=[_cloudkit.AssetUploadTokenRetrieveRequestAuthorizePutPutDataChunkInfo(chunk_checksum=chunk.hash, chunk_encryption_key=b"\x01" + chunk.key, chunk_length=len(chunk.data)) for chunk in chunks] # type: ignore # TODO FIX TYPING NONE
                ),
                f3=81,
            ),
            unk1=1,
            
            header=[_cloudkit.NamedHeader(k, v) for (k,v) in mmcs.MMCS_HEADERS.items()] + [_cloudkit.NamedHeader(
                    "x-mme-client-info",
                    "<MacBookPro18,3> <macOS;13.4.1;22F82> <com.apple.icloud.content/2050.13.1.1 (com.apple.CloudKit/(null))>",
                ),  # TODO: Use ClientInfo builder?
            ]
        ),
    )

    print(request)

    return _delimit_messages([request.SerializeToString()])


def _delimit_messages(messages: list[bytes]):
    output = BytesIO()
    for message in messages:
        output.write(_utils.ULEB128.encode(len(message)))
        output.write(message)
    return output.getvalue()


def _undelimit_messages(data: bytes):
    output = []
    datar = BytesIO(data)
    while True:
        # Make sure we don't read past the end of the data
        if datar.tell() >= len(data):
            break
        length, read = _utils.ULEB128.decode_reader(datar)
        if length == 0:
            break
        output.append(datar.read(length))
    return output
